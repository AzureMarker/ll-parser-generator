use crate::lexer::Token;
use std::ops::Range;

grammar<'input>;

// Example grammar file:
// use some::imports;
//
// token Token {
//     "STR_ALIAS" => Token::MyToken
// }
//
// grammar;
//
// Nonterminal: TheType = {
//     some symbols here "STR_ALIAS" => action code here,
//     second production here => second action here,
// };

pub Grammar = Import* TokenDecl GrammarDecl Nonterminal*;

Import: () = "use" "IMPORT_CODE" ";" => ();

TokenDecl: () = "token" "{" "}" => ();

GrammarDecl = "grammar" ";";

Nonterminal = "IDENT" ":" TypeRef "=" Productions ";";

TypeRef: () = "IDENT" => ();

Productions: () = {
    // Single production
    Production => (),
    "{" Comma<Productions> "}" => (),
};

Production: () = Symbol+ "=>" "CODE" => ();

Symbol: () = "IDENT" => ();

// Allows trailing element
Comma<T>: Vec<T> = {
   <mut v:(<T> ",")*> <e:T?> => {
       v.extend(e);
       v
   }
};

extern {
    type Location = usize;
    type Error = Range<usize>;

    enum Token<'input> {
        "IDENT" => Token::Identifier(<&'input str>),
        "IMPORT_CODE" => Token::ImportCode(<&'input str>),
        "CODE" => Token::Code(<&'input str>),
        "grammar" => Token::Grammar,
        "token" => Token::Token,
        "use" => Token::Use,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        ";" => Token::Semicolon,
        ":" => Token::Colon,
        "=>" => Token::EqArrow,
        "=" => Token::Equal,
        "," => Token::Comma,
        ")" => Token::RParen,
        "(" => Token::LParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "|" => Token::VBar
        }
}