use crate::ast::*;
use crate::lexer::Token;
use std::ops::Range;

grammar<'input>;

// Example grammar file:
// use some::imports;
//
// token Token {
//     "STR_ALIAS" => Token::MyToken
// }
//
// grammar;
//
// Nonterminal: TheType = {
//     some symbols here "STR_ALIAS" => action code here,
//     second production here => second action here,
// };
//
// SecondNonterminal: OtherType = some symbols => action code;

pub Grammar: AstGrammar<'input> =
    <imports:Import*> <token_decl:TokenDecl> GrammarDecl <nonterminals:Nonterminal*>
    => AstGrammar { imports, token_decl, nonterminals };

Import = "use" <"IMPORT_CODE"> ";";

TokenDecl: AstTokenDecl = "token" "{" "}" => AstTokenDecl {};

GrammarDecl: () = "grammar" ";" => ();

Nonterminal: AstNonterminal<'input> =
    <name:"IDENT"> ":" <ty:TypeRef> "=" <productions:Productions> ";"
    => AstNonterminal { name, ty, productions };

TypeRef: AstTypeRef = "IDENT" => AstTypeRef {};

Productions: Vec<AstProduction<'input>> = {
    // Single production
    Production => vec![<>],
    "{" <Comma<Production>> "}",
};

Production : AstProduction<'input> = <symbols:Symbol+> "=>" <code:"ACTION_CODE">
    => AstProduction { symbols, code };

Symbol: AstSymbol = "IDENT" => AstSymbol {};

// Allows trailing element
Comma<T>: Vec<T> = {
   <mut v:(<T> ",")*> <e:T?> => {
       v.extend(e);
       v
   }
};

extern {
    type Location = usize;
    type Error = Range<usize>;

    enum Token<'input> {
        "IDENT" => Token::Identifier(<&'input str>),
        "IMPORT_CODE" => Token::ImportCode(<&'input str>),
        "ACTION_CODE" => Token::ActionCode(<&'input str>),
        "grammar" => Token::Grammar,
        "token" => Token::Token,
        "use" => Token::Use,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        ";" => Token::Semicolon,
        ":" => Token::Colon,
        "=>" => Token::EqArrow,
        "=" => Token::Equal,
        "," => Token::Comma,
        ")" => Token::RParen,
        "(" => Token::LParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "|" => Token::VBar
        }
}